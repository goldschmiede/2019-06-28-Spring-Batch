== Parallelisierung

[.lead]
Vorüberlegungen zur Parallelisierung

[%step]
* Muss das sein?
** -> Lieber erst mal die Chunkgröße justieren
* Ihr seid nicht allein!
* Sinnvoll bei langsamer I/O
    ** Archivsystem
    ** Webservice

=== Möglichkeiten der Parallelsierung

* Einen Step mit mehreren Threads ausführen
* Mehrere Steps gleichzeitig ausführen (Flows)
* Partitionierung
* Remote Chunking

=== Step mit mehreren Threads ausführen

[source, java, indent=0]
----
include::{samples}/src/main/java/com/anderscore/goldschmiede/springbatch/samples/parallel/ParallelStepConfig.java[tag=step]
----

* Reader, Processor und Writer müssen *thread-save* sein
* Chunk-size bestimmt Synchronisationsaufwand

=== TaskExecutor in Spring-Batch

[plantuml, BatchConfigurer, svg, width=1800]
....
interface TaskExecutor
SyncTaskExecutor .|> TaskExecutor
TaskExecutor <|.. SimpleAsyncTaskExecutor
TaskExecutor <|... ThreadPoolTaskExecutor

class TaskExecutorRepeatTemplate {
    throttleLimit: int
}

TaskExecutor <- TaskExecutorRepeatTemplate
TaskExecutor <-- SplitState
TaskExecutor <-- TaskExecutorPartitionHandler
TaskExecutor <--- SimpleJobLauncher
note bottom
Ermöglicht asynchrone
Ausführung eines Jobs
end note

class AbstractTaskletStepBuilder {
    taskExecutor(taskExecutor: TaskExecutor)
    throttleLimit(throttleLimit: int)
}

AbstractTaskletStepBuilder <|-- TaskletStepBuilder
AbstractTaskletStepBuilder <|-- SimpleStepBuilder

class PartitionStepBuilder {
    taskExecutor(taskExecutor: TaskExecutor)
    gridSize(gridSize: int)
}

SimpleStepBuilder <-[hidden]- PartitionStepBuilder

class FlowBuilder {
    split(taskExecutor: TaskExecutor)
}

class SimpleJobBuilder {
    split(taskExecutor: TaskExecutor)
}

FlowBuilder <-[hidden]- SimpleJobBuilder 
....

=== Paritionierung

* Aufteilung der Datenmenge eines Steps auf mehrere Steps
* Sinnvolle Kriterien zur Aufteilung notwendig
* Ermöglicht auch Remote-Verarbeitung
* Auch ohne Partitionierung in Kombination mit @StepScope sinnvoll

=== PartitionStep

[plantuml, PartitionStep, svg, height=760]
....
-> PartitionStep: execute
activate PartitionStep

participant PartitionHandler #lightgrey
PartitionStep -> PartitionHandler: handle
activate PartitionHandler

participant StepExecutionSplitter #lightgrey
PartitionHandler -> StepExecutionSplitter: split
activate StepExecutionSplitter
StepExecutionSplitter -> Partitioner: partition
activate Partitioner
StepExecutionSplitter <- Partitioner
deactivate Partitioner
PartitionHandler <- StepExecutionSplitter
deactivate StepExecutionSplitter

participant StepExecutionAggregator

PartitionHandler -> Step: execute
activate Step
PartitionHandler <- Step
deactivate Step

PartitionStep <- PartitionHandler
deactivate PartitionHandler

PartitionStep -> StepExecutionAggregator: aggregate
activate StepExecutionAggregator
PartitionStep <- StepExecutionAggregator
deactivate StepExecutionAggregator

<- PartitionStep
deactivate PartitionStep
....

=== Remote Chunking 
=> Für rechenintensive Steps

image::spring-batch/remote-chunking.png[width=1000]

== Listener

[.lead]
Listener Interfaces und deren Registrierung

[plantuml, Listener, svg, width=100%]
....
class StepBuilderHelper {
    listener(listener: StepExecutionListener): StepBuilderHelper
    listener(listener: Object): StepBuilderHelper
}
note left
Es können beliebige Objekte
mit entsprechenden Listener
Annotationen registriert werden.
end note

class AbstractTaskletStepBuilder {
    stream(stream: ItemStream): AbstractTaskletStepBuilder
    listener(listener: ChunkListener): AbstractTaskletStepBuilder
}

StepBuilderHelper <|-- AbstractTaskletStepBuilder

class SimpleStepBuilder {
    listener(listener: ItemProcessListener): SimpleStepBuilder
    listener(listener: ItemReadListener): SimpleStepBuilder
    listener(listener: ItemWriteListener): SimpleStepBuilder
}

AbstractTaskletStepBuilder <|-- SimpleStepBuilder
note left
Reader, Writer und Processer werden
immer als Listener registriert, sofern
sie ein Listener-Interface implementieren
oder entsprechend Annotierte Methoden haben.
end note

class FaultTolerantStepBuilder {
    listener(listener: RetryListener): FaultTolerantStepBuilder
    listener(listener: SkipListener): FaultTolerantStepBuilder
}

SimpleStepBuilder <|-- FaultTolerantStepBuilder

interface JobListener {
    beforeJob()
    afterJob()
}

interface ItemStream {
    update(arg0: ExecutionContext)
    close()
    open(arg0: ExecutionContext)
}

ItemStream <. AbstractTaskletStepBuilder

interface StepListener {
}

interface StepExecutionListener {
    beforeStep(arg0: StepExecution)
    afterStep(arg0: StepExecution): ExitStatus
}

StepExecutionListener -|> StepListener

interface ChunkListener {
    beforeChunk(arg0: ChunkContext)
    afterChunk(arg0: ChunkContext)
    afterChunkError(arg0: ChunkContext)
}

StepListener <|-- ChunkListener

interface StepListener {
}

interface ItemReadListener {
    beforeRead()
    afterRead(arg0: Object)
    onReadError(arg0: Exception)
}

StepListener <|--- ItemReadListener

interface ItemProcessListener {
    beforeProcess(arg0: Object)
    onProcessError(arg0: Object, arg1: Exception)
    afterProcess(arg0: Object, arg1: Object)
}

StepListener <|--- ItemProcessListener

interface ItemWriteListener {
    afterWrite(arg0: List)
    beforeWrite(arg0: List)
    onWriteError(arg0: Exception, arg1: List)
}

StepListener <|--- ItemWriteListener

interface SkipListener {
    onSkipInProcess(arg0: Object, arg1: Throwable)
    onSkipInRead(arg0: Throwable)
    onSkipInWrite(arg0: Object, arg1: Throwable)
}

StepListener <|-- SkipListener

class StepListenerSupport {
}

StepExecutionListener <|.. StepListenerSupport

ChunkListener <|.. StepListenerSupport

ItemReadListener <|.. StepListenerSupport

ItemProcessListener <|.. StepListenerSupport

ItemWriteListener <|.. StepListenerSupport

SkipListener <|.. StepListenerSupport

interface RetryListener {
    close(arg0: RetryContext, arg1: RetryCallback, arg2: Throwable)
    open(arg0: RetryContext, arg1: RetryCallback): boolean
    onError(arg0: RetryContext, arg1: RetryCallback, arg2: Throwable)
}

RetryListener <. FaultTolerantStepBuilder
....

== Scope

[.lead]
@StepScope und @JobScope

* Erzeugt Bean für Lebenszyklus eines Steps bzw. eines Jobs
* Ermöglicht _late binding_ über `@Value("++#++{jobParameters[input.file.name]}")`, +
  `@Value("++#++{jobExecutionContext[key]}")` oder +
  `@Value("++#++{stepExecutionContext[minValue]}")`
* `@StepScope` bei Reader, Processor oder Writer in Kombination mit Partitionierung sinnvoll

include::index.adoc[]